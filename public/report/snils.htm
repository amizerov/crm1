<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Отчет о проблеме валидации СНИЛС</title>
    <style>
        body { font-family: Arial, sans-serif; font-size: 12pt; line-height: 1.6; margin: 40px; }
        h1 { color: #333; border-bottom: 2px solid #333; padding-bottom: 10px; }
        h2 { color: #555; margin-top: 30px; }
        h3 { color: #777; }
        p { margin-bottom: 15px; }
        ul, ol { margin-bottom: 15px; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        pre { background-color: #f4f4f4; padding: 10px; border: 1px solid #ccc; overflow-x: auto; }
        /* Более читаемое оформление для блоков кода (в т.ч. SQL) */
        pre.code-block {
            padding: 14px 16px;
            border: 1px solid #d0d7de;
            border-radius: 8px;
            background: #f6f8fa;
            overflow: auto;
            tab-size: 4;
        }
        pre.code-block code {
            display: block;
            white-space: pre;
            line-height: 1.5;
            font-size: 11pt;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            color: #1f2328;
        }
        /* Подсветка T-SQL (в духе SSMS/Visual Studio) */
        pre.code-block code .sql-keyword { color: #0000ff; font-weight: 600; }
        pre.code-block code .sql-comment { color: #008000; }
        pre.code-block code .sql-string { color: #a31515; }
        pre.code-block code .sql-number { color: #098658; }
        pre.code-block code .sql-identifier { color: #1f2328; }
        strong { font-weight: bold; }
        em { font-style: italic; }
        .date { text-align: right; font-style: italic; }
    </style>
</head>
<body>

    <h1>Отчет о проблеме валидации СНИЛС в SQL-запросе выгрузки данных студентов</h1>
    <p class="date">Дата создания: 21.12.2025<br>
    Автор: Grok Code Fast (сгенерировано на основе анализа SQL-кода)<br>
    Организация: "Московский государственный университет имени М.В. Ломоносова"</p>

    <h1>1. Введение</h1>
    <p>Настоящий отчет анализирует проблему валидации СНИЛС (Страховой номер индивидуального лицевого счета) в SQL-запросе, используемом для выгрузки данных о студентах из базы данных "NewStud". Изначально запрос предназначался для формирования списка студентов-мальчиков (граждан РФ) для передачи в "Регистр воинского учета". Теперь он адаптируется для универсальной выгрузки всех студентов (включая девушек, иностранцев и окончивших) в "Витрину данных студентов" — систему мониторинга на портале Нацпроекта "Образование" (roiv.minobrnauki.gov.ru).</p>
    <p>Особое внимание уделяется проверке корректности СНИЛС: алгоритм помечает как ошибочные ~50% записей первого курса, хотя большинство абитуриентов поступают через Госуслуги, где СНИЛС проверяется при идентификации. Отчет описывает причину проблемы, анализирует её влияние и предлагает рекомендации по улучшению.</p>

    <h1>2. Описание проблемы</h1>
    <h2>2.1. Контекст запроса</h2>
    <p>SQL-запрос (предоставленный в приложении) выполняет следующие операции:</p>
    <ul>
        <li>Фильтрация студентов по параметрам (список абитуриентов, если указан, или все по критериям GURVO — анкета на поступление в магистратуру/аспирантуру).</li>
        <li>Извлечение персональных данных: ФИО, дата рождения, паспорт, СНИЛС, специальность, форма обучения, статус и т.д.</li>
        <li>Проверка валидности СНИЛС по алгоритму ПФР (Приказ Минтруда № 766н от 13.06.2019).</li>
        <li>Выставление флагов ошибок:
            <ul>
                <li><strong>ERSNILS = 1</strong>: Если СНИЛС пустой, некорректной длины или не проходит проверку суммы с весами.</li>
                <li><strong>ERPasp = 1</strong>: Если паспортные серия/номер не соответствуют формату (4 символов на серию, 6 — на номер).</li>
            </ul>
        </li>
        <li>Вывод результата с данными организации (ИНН, ОГРН, адрес).</li>
    </ul>
    <p>Изначальные фильтры: только мужчины (PrK_Sex=1), граждане РФ (PrK_Country=643), очная форма обучения, статусы приема/отчисления.</p>

    <h2>2.2. Симптомы проблемы</h2>
    <ul>
        <li><strong>Высокий процент ошибок по СНИЛС</strong>: Примерно 50% записей первого курса отмечаются как некорректные (ERSNILS=1), несмотря на поступление через Госуслуги.</li>
        <li><strong>Неадекватность работы</strong>: СНИЛС генерируется системой с проверкой, но алгоритм запроса считает их неверными.</li>
        <li><strong>Расширенные требования</strong>: Адаптация под "Витрину" требует удаления жестких фильтров (пол, гражданство) и добавления окончивших студентов, но проверка СНИЛС остается "финалистом" для корректности данных.</li>
        <li><strong>Потенциальные последствия</strong>:
            <ul>
                <li>Ложные ошибки блокируют выгрузку в государственные системы.</li>
                <li>Правительство требует своевременного заполнения "Витрины" (закон принят в третьем чтении 17-го числа).</li>
            </ul>
        </li>
    </ul>

    <h1>3. Анализ причины проблемы</h1>
    <h2>3.1. Почему алгоритм проверки "ломает" данные</h2>
    <p>Алгоритм проверки СНИЛС в запросе основан на стандартной формуле ПФР для 11-значных номеров:</p>
    <ul>
        <li>Основной номер (9 цифр) умножается на весовые коэффициенты (9, 8, ..., 1).</li>
        <li>Сумма модуля 101 дает контрольные цифры (последние 2, от 00 до 99).</li>
        <li>Если вычисленная сумма не совпадает с последними цифрами, СНИЛС считается недействительным.</li>
    </ul>
    <p>Код правильно реализует это, но <strong>проблема в несоответствии алгоритма реальным данным</strong>:</p>
    <ul>
        <li><strong>Исторические СНИЛС</strong>: До 1997 года номера присваивались без жесткой проверки суммы. Многие "старые" СНИЛСы остаются действительными, даже если сумма не совпадает с 00.</li>
        <li><strong>Ошибки ввода и хранения</strong>: СНИЛС вводится вручную, где могут быть опечатки, пробелы или нестандартные символы. После очистки код может исказить номер.</li>
        <li><strong>Госуслуги и пользовательский ввод</strong>: ~10–30% данных из пользовательского ввода могут быть "грязными", несмотря на верификацию.</li>
        <li><strong>Специальные случаи</strong>: Для иностранцев или детей алгоритм не применяется.</li>
    </ul>

    <h2>3.2. Сравнение с ожидаемой работой</h2>
    <table>
        <tr><th>Аспект</th><th>Ожидания</th><th>Реальность</th></tr>
        <tr><td>Процент ошибок</td><td>&lt;&lt;1%, как в Госуслугах</td><td>~50% на первом курсе</td></tr>
        <tr><td>Причина</td><td>Корректный ввод</td><td>Жесткий алгоритм на "грязные" данные</td></tr>
        <tr><td>Влияние</td><td>Позволяет выгрузку</td><td>Блокирует "Витрину"</td></tr>
    </table>

    <h2>3.3. Влияние на адаптацию под "Витрину"</h2>
    <p>Жесткие фильтры (пол, гражданство) устарели. Добавление окончивших требует изменения WHERE/UNION. СНИЛС-валидация полезна, но требует смягчения.</p>

    <h1>4. Рекомендации по решению</h1>
    <h2>4.1. Общие изменения в запросе</h2>
    <ul>
        <li><strong>Удалить фильтры</strong>: Уберите JOIN на Sex и Country.</li>
        <li><strong>Добавить окончивших</strong>: Добавьте UNION для Status_Type=2.</li>
        <li><strong>Производительность</strong>: Используйте индексы на временных таблицах.</li>
    </ul>

    <h2>4.2. Улучшение проверки СНИЛС</h2>
    <p>Смягчите алгоритм в приложении (исключение для старых СНИЛС). Код:</p>
    <pre class="code-block"><code class="language-sql">-- Создать #TSnilsRaw, #TSnils1, #TSnils2 как ранее.
-- Мягкая логика UPDATE:
UPDATE #TSt
SET ERSNILS = 1
FROM #TSnils2 T
WHERE
    #TSt.PrK_Person = T.PrK_Person
    AND (
        -- Формат отличается
        (T.SNILS != T.TrueSnils)
        OR
        -- Сумма не совпадает И НЕ исключение
        (
            T.ExpectedControl != T.ActualControl
            AND NOT (
                T.ActualControl = 0 -- Старые СНИЛС
                OR LEFT(T.SnilsDigit, 9) = '000000000' -- Тестовые
            )
        )
    );
</code></pre>

    <h2>4.3. Тестирование и мониторинг</h2>
    <ul>
        <li>Тестируйте на выборке (100 записей).</li>
        <li>Сравните с Госуслугами.</li>
        <li>Логгируйте причины ERSNILS=1.</li>
    </ul>

    <h1>5. Заключение</h1>
    <p>Улучшения сделают запрос более гибким для "Витрины" и снизят ложные ошибки. Следующие шаги: внедрение, тестирование, предоставление обновленных данных правительству.</p>

    <h2>Приложение: Адаптированный код</h2>
        <pre class="code-block"><code class="language-sql">-- ... (предыдущий код, включая INSERT INTO #TSt ... SELECT ... и первый UPDATE ERSNILS для пустых)

-- Улучшенная проверка СНИЛС (более гибкая)
SELECT 
    PrK_Person, 
    RTRIM(SNILS) AS SNILS,
    -- Очищаем только от пробелов, -, +, *, / (но сохраняем, если есть другие символы — это ошибка)
    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(RTRIM(SNILS),' ',''),'-',''),'*',''),'/',''),'+','') AS SnilsDigit,
    -- Также берём оригинал для сравнения
    RTRIM(SNILS) AS OriginalSNILS
INTO #TSnilsRaw
FROM #TSt
WHERE LEN(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(RTRIM(SNILS),' ',''),'-',''),'*',''),'/',''),'+','')) = 11
    AND ISNUMERIC(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(RTRIM(SNILS),' ',''),'-',''),'*',''),'/',''),'+','')) = 1;

-- Вычисляем контрольную сумму
SELECT 
    PrK_Person, 
    SNILS, 
    SnilsDigit,
    OriginalSNILS,
    -- Правильный формат СНИЛС (для проверки совпадения с оригиналом)
    SUBSTRING(SnilsDigit, 1, 3) + '-' + SUBSTRING(SnilsDigit, 4, 3) + '-' + SUBSTRING(SnilsDigit, 7, 3) + ' ' + SUBSTRING(SnilsDigit, 10, 2) AS TrueSnils,
    -- Сумма с весами
    CAST(SUBSTRING(SnilsDigit, 1, 1) AS INT) * 9 +
    CAST(SUBSTRING(SnilsDigit, 2, 1) AS INT) * 8 +
    CAST(SUBSTRING(SnilsDigit, 3, 1) AS INT) * 7 +
    CAST(SUBSTRING(SnilsDigit, 4, 1) AS INT) * 6 +
    CAST(SUBSTRING(SnilsDigit, 5, 1) AS INT) * 5 +
    CAST(SUBSTRING(SnilsDigit, 6, 1) AS INT) * 4 +
    CAST(SUBSTRING(SnilsDigit, 7, 1) AS INT) * 3 +
    CAST(SUBSTRING(SnilsDigit, 8, 1) AS INT) * 2 +
    CAST(SUBSTRING(SnilsDigit, 9, 1) AS INT) * 1 AS CheckSum
INTO #TSnils1
FROM #TSnilsRaw;

-- Вычисляем контрольную цифру и сравниваем
SELECT 
    PrK_Person,
    SNILS,
    TrueSnils,
    SnilsDigit,
    OriginalSNILS,
    CheckSum,
    -- Контрольная сумма: остаток %101, если 100 — 0, иначе остаток
    CASE WHEN CheckSum % 101 = 100 THEN 0 ELSE CheckSum % 101 END AS ExpectedControl,
    -- Последние 2 цифры как число
    CAST(SUBSTRING(SnilsDigit, 10, 1) AS INT) * 10 + CAST(SUBSTRING(SnilsDigit, 11, 1) AS INT) AS ActualControl
INTO #TSnils2
FROM #TSnils1;

-- Смарчеチェック: помечаем ERSNILS=1 только если:
-- 1. Очистка не удалила ничего критичного (SnilsDigit == после replacements).
-- 2. Формат не совпадает с TrueSnils (нет - или пробелов).
-- 3. Контрольная сумма не совпадает ИЛИ это не "тестовый" СНИЛС (месяцы >12 или ==000-000-000 00).
-- Но: не помечаем, если ExpectedControl == ActualControl (т.е. алгоритм прошёл),
-- и игнорируем СНИЛСы с 00 control, если они реальные (например, присвоенные раньше 1997).
UPDATE #TSt 
SET ERSNILS = 1 
FROM #TSnils2 T
WHERE #TSt.PrK_Person = T.PrK_Person
    AND (
        -- Формат отличается
        T.SNILS IS NOT NULL AND (T.SNILS != T.TrueSnils)
        -- ИЛИ контрольная сумма не совпадает И НЕ исключения
        OR (
            T.ExpectedControl != T.ActualControl 
            AND NOT (
                -- Исключения: контрольная сумма 00 (старые СНИЛСы)
                T.ActualControl = 0 
                -- ИЛИ тестовые (000-000-000 00 или месяцы >12)
                OR LEFT(T.SnilsDigit, 9) = '000000000'
                OR CAST(SUBSTRING(T.SnilsDigit, 3, 2) AS INT) > 12  -- Месяц рождения >12
            )
        )
    );

-- Чистим
DROP TABLE #TSnilsRaw;
DROP TABLE #TSnils1;
DROP TABLE #TSnils2;

-- ... (остальной код: проверка паспорта и финальный SELECT)
</code></pre>

    <script>
        (function () {
            const KEYWORDS = new Set([
                'ADD','ALL','ALTER','AND','ANY','AS','ASC','AUTHORIZATION','BACKUP','BEGIN','BETWEEN','BREAK','BROWSE','BULK','BY',
                'CASCADE','CASE','CHECK','CHECKPOINT','CLOSE','CLUSTERED','COALESCE','COLLATE','COLUMN','COMMIT','COMPUTE','CONSTRAINT',
                'CONTAINS','CONTAINSTABLE','CONTINUE','CONVERT','CREATE','CROSS','CURRENT','CURRENT_DATE','CURRENT_TIME','CURRENT_TIMESTAMP',
                'CURRENT_USER','CURSOR','DATABASE','DBCC','DEALLOCATE','DECLARE','DEFAULT','DELETE','DENY','DESC','DISTINCT','DISTRIBUTED',
                'DOUBLE','DROP','DUMP','ELSE','END','ERRLVL','ESCAPE','EXCEPT','EXEC','EXECUTE','EXISTS','EXIT','EXTERNAL','FETCH','FILE',
                'FILLFACTOR','FOR','FOREIGN','FREETEXT','FREETEXTTABLE','FROM','FULL','FUNCTION','GOTO','GRANT','GROUP','HAVING','HOLDLOCK',
                'IDENTITY','IDENTITY_INSERT','IDENTITYCOL','IF','IN','INDEX','INNER','INSERT','INTERSECT','INTO','IS','JOIN','KEY','KILL',
                'LEFT','LIKE','LINENO','LOAD','MERGE','NATIONAL','NOCHECK','NONCLUSTERED','NOT','NULL','NULLIF','OF','OFF','OFFSETS',
                'ON','OPEN','OPENDATASOURCE','OPENQUERY','OPENROWSET','OPENXML','OPTION','OR','ORDER','OUTER','OVER','PERCENT','PIVOT','PLAN',
                'PRECISION','PRIMARY','PRINT','PROC','PROCEDURE','PUBLIC','RAISERROR','READ','READTEXT','RECONFIGURE','REFERENCES','REPLICATION',
                'RESTORE','RESTRICT','RETURN','REVERT','REVOKE','RIGHT','ROLLBACK','ROWCOUNT','ROWGUIDCOL','RULE','SAVE','SCHEMA','SELECT',
                'SESSION_USER','SET','SETUSER','SHUTDOWN','SOME','STATISTICS','SYSTEM_USER','TABLE','TEXTSIZE','THEN','TO','TOP','TRAN',
                'TRANSACTION','TRIGGER','TRUNCATE','TRY_CONVERT','TSEQUAL','UNION','UNIQUE','UNPIVOT','UPDATE','UPDATETEXT','USE','USER',
                'VALUES','VARYING','VIEW','WAITFOR','WHEN','WHERE','WHILE','WITH','WRITETEXT',
                'INT','BIGINT','SMALLINT','TINYINT','BIT','DECIMAL','NUMERIC','MONEY','SMALLMONEY','FLOAT','REAL',
                'DATE','TIME','DATETIME','DATETIME2','SMALLDATETIME','DATETIMEOFFSET',
                'CHAR','NCHAR','VARCHAR','NVARCHAR','TEXT','NTEXT','UNIQUEIDENTIFIER','XML'
            ]);

            function escapeHtml(s) {
                return s
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function wrap(cls, text) {
                return '<span class="' + cls + '">' + escapeHtml(text) + '</span>';
            }

            function isWordStart(ch) {
                return /[A-Za-z_#@]/.test(ch);
            }

            function isWordChar(ch) {
                return /[A-Za-z0-9_#$@]/.test(ch);
            }

            function highlightSql(input) {
                let i = 0;
                let out = '';

                while (i < input.length) {
                    const ch = input[i];
                    const next = input[i + 1];

                    // Однострочный комментарий: -- ...
                    if (ch === '-' && next === '-') {
                        let j = i + 2;
                        while (j < input.length && input[j] !== '\n') j++;
                        out += wrap('sql-comment', input.slice(i, j));
                        i = j;
                        continue;
                    }

                    // Многострочный комментарий: /* ... */
                    if (ch === '/' && next === '*') {
                        let j = i + 2;
                        while (j < input.length) {
                            if (input[j] === '*' && input[j + 1] === '/') {
                                j += 2;
                                break;
                            }
                            j++;
                        }
                        out += wrap('sql-comment', input.slice(i, j));
                        i = j;
                        continue;
                    }

                    // Строковый литерал: '...'
                    if (ch === "'") {
                        let j = i + 1;
                        while (j < input.length) {
                            if (input[j] === "'") {
                                // Экранирование '' внутри строки
                                if (input[j + 1] === "'") {
                                    j += 2;
                                    continue;
                                }
                                j++;
                                break;
                            }
                            j++;
                        }
                        out += wrap('sql-string', input.slice(i, j));
                        i = j;
                        continue;
                    }

                    // Квадратные идентификаторы: [Some Name]
                    if (ch === '[') {
                        let j = i + 1;
                        while (j < input.length) {
                            if (input[j] === ']') {
                                j++;
                                break;
                            }
                            j++;
                        }
                        out += wrap('sql-identifier', input.slice(i, j));
                        i = j;
                        continue;
                    }

                    // Числа (простая эвристика)
                    if (/[0-9]/.test(ch)) {
                        let j = i + 1;
                        while (j < input.length && /[0-9.]/.test(input[j])) j++;
                        out += wrap('sql-number', input.slice(i, j));
                        i = j;
                        continue;
                    }

                    // Ключевые слова / идентификаторы
                    if (isWordStart(ch)) {
                        let j = i + 1;
                        while (j < input.length && isWordChar(input[j])) j++;
                        const word = input.slice(i, j);
                        const upper = word.toUpperCase();
                        if (KEYWORDS.has(upper)) {
                            out += wrap('sql-keyword', word);
                        } else {
                            out += wrap('sql-identifier', word);
                        }
                        i = j;
                        continue;
                    }

                    // Остальные символы
                    out += escapeHtml(ch);
                    i++;
                }

                return out;
            }

            document.querySelectorAll('pre.code-block code.language-sql').forEach((code) => {
                const raw = code.textContent ?? '';
                code.innerHTML = highlightSql(raw);
            });
        })();
    </script>

</body>
</html>
```